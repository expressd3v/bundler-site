#intro
  If you just want to know our recommended workflow, and don't care about the rationale, feel
  free to jump to the summary below.
%br

#standalone
  %h2#bundlers-purpose-and-rationale
    Bundler's Purpose and Rationale
  %p
    First, you declare these dependencies in a file at the root of your application, called
    <code>Gemfile</code>. It looks something like this:

  :highlight_ruby
    source 'https://rubygems.org'

    gem 'rails', '3.0.0.rc'
    gem 'rack-cache'
    gem 'nokogiri', '~> 1.4.2'

  %p
    This <code>Gemfile</code> says a few things. First, it says that bundler should look for gems
    declared in the <code>Gemfile</code> at <code>http://rubygems.org</code>. You can declare
    multiple Rubygems sources, and bundler will look for gems in the order you declared the
    sources.

  %p
    Next, you declare a few dependencies:

  %ul
    %li on version <code>3.0.0.rc</code> of <code>rails</code>
    %li on any version of <code>rack-cache</code>
    %li on a version of <code>nokogiri</code> that is <code>>= 1.4.2</code> but <code>< 1.5.0</code>

  %p
    After declaring your first set of dependencies, you tell bundler to go get them:

  :highlight_plain
    $ bundle install    # <code>bundle</code> is a shortcut for <code>bundle install</code>

  %p
    Bundler will connect to <code>rubygems.org</code> (and any other sources that you declared),
    and find a list of all of the required gems that meet the requirements you specified. Because
    all of the gems in your <code>Gemfile</code> have dependencies of their own (and some of
    those have their own dependencies), running <code>bundle install</code> on the
    <code>Gemfile</code> above will install quite a few gems.

  :highlight_plain
    $ bundle install
    Fetching source index for http://gemcutter.org/
    Using rake (0.8.7)
    Using abstract (1.0.0)
    Installing activesupport (3.0.0.rc)
    Using builder (2.1.2)
    Using i18n (0.4.1)
    Installing activemodel (3.0.0.rc)
    Using erubis (2.6.6)
    Using rack (1.2.1)
    Installing rack-mount (0.6.9)
    Using rack-test (0.5.4)
    Using tzinfo (0.3.22)
    Installing actionpack (3.0.0.rc)
    Using mime-types (1.16)
    Using polyglot (0.3.1)
    Using treetop (1.4.8)
    Using mail (2.2.5)
    Installing actionmailer (3.0.0.rc)
    Using arel (0.4.0)
    Installing activerecord (3.0.0.rc)
    Installing activeresource (3.0.0.rc)
    Using bundler (1.0.0.rc.3)
    Installing nokogiri (1.4.3.1) with native extensions
    Installing rack-cache (0.5.2)
    Installing thor (0.14.0)
    Installing railties (3.0.0.rc)
    Installing rails (3.0.0.rc)
    Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

  %p
    If any of the needed gems are already installed, Bundler will use them. After installing
    any needed gems to your system, bundler writes a snapshot of all of the gems and
    versions that it installed to <code>Gemfile.lock</code>.

  %h2#deploying-your-application
    Deploying Your Application

  %p
    When you run <code>bundle install</code>, bundler will (by default), install your gems
    to your system repository of gems. This means that they will show up in <code>gem
    list</code>. Additionally, if you are developing a number of applications, you will not
    need to download and install gems in common for each application. This is nice for
    development, but somewhat problematic for deployment.

  %p
    In a deployment scenario, the Unix user you deploy with may not have access to install
    gems to a system location. Even if the user does (or you use <code>sudo</code>), the
    user that boots the application may not have access to them. For instance, Passenger
    runs its Ruby subprocesses with the user <code>nobody</code>, a somewhat restricted
    user. The tradeoffs in a deployment environment lean more heavily in favor of isolation
    (even at the cost of a somewhat slower deploy-time <code>bundle install</code> when some
    third-party dependencies have changed).

  %p
    As a result, bundler comes with a <code>--deployment</code> flag that encapsulates the
    best practices for using bundler in a deployment environment. These practices are based
    on significant feedback we have received during the development of bundler, as well as a
    number of bug reports that mostly reflected a misunderstanding of how to best configure
    bundler for deployment. The <code>--deployment</code> flags adds the following defaults:

  %ul
    %li
      Instead of installing gems to the system location, bundler will install gems to
      <code>vendor/bundle</code> inside your application. Bundler will transparently remember
      this location when you invoke it inside your application (with
      <code>Bundler.setup</code> and <code>Bundler.require</code>).
    %li
      Bundler will not use gems already installed to your system, even if they exist.
    %li
      If you have run <code>bundle pack</code>, checked in the <code>vendor/cache</code>
      directory, and do not have any git gems, Bundler will not contact the internet while
      installing your bundle.
    %li
      Bundler will require a <code>Gemfile.lock</code> snapshot, and fail if you did not
      provide one.
    %li
      Bundler will not transparently update your <code>Gemfile.lock</code> if it is out of
      date with your <code>Gemfile</code>

  %p
    If you use Capistrano, you should symlink <code>vendor/bundle</code> to
    <code>shared/vendor_bundle</code> so that bundler will share your installed gems between
    deployments (making things zippy if you didn't make any changes), but still give you the
    benefits of isolation from other applications.

  %p
    By defaulting the bundle directory to <code>vendor/bundle</code>, and installing your
    bundle as part of your deployment process, you can be sure that the same Unix user that
    checked out your application also installed the third-party code your application needs.
    This means that if Passenger (or Unicorn) can see your application, it can also see its
    dependencies.

  %p
    The <code>--deployment</code> flag requires an up-to-date <code>Gemfile.lock</code> to
    ensure that the testing you have done (in development and staging) actually reflects the
    code you put into production. You can run <code>bundle check</code> before deploying
    your application to make sure that your <code>Gemfile.lock</code> is up-to-date. Note
    that it will always be up-to-date if you have run <code>bundle install</code>,
    successfully booted your application (or run your tests) since the last time you changed
    your <code>Gemfile</code>.

  %h2#notes
    Notes

  %p
    [1] For instance, if <code>rails 3.0.0</code> depended on <code>rack 2.0</code>, that
    gem would still satisfy the requirement of <code>rack-cache</code>, which declares
    <code>>= 1.0</code> as a dependency. Of course, you could argue that
    <code>rack-cache</code> is silly for depending on open-ended versions, but these
    situations exist (extensively) in the wild, and projects often find themselves between a
    rock and a hard place when deciding what version to depend on. Constrain the dependency
    too much (<code>rack =1.2.1</code>) and you make it hard to use your project in other
    compatible projects. Constrain it too little (<code>rack >= 1.0</code>) and a new
    release of Rack may break your code. Using dependencies like <code>rack ~> 1.2.1</code>
    and versioning code in a SemVer compliant way mostly solves this problem, but it assumes
    universal compliance. Since Rubygems has over 100,000 packages, this assumption simply
    doesn't hold in practice.

